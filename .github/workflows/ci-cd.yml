name: CI/CD Pipeline

on:
  push:
    branches: [ main, feature/**, fix/**, release/**, hotfix/** ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ghcr.io/asyncsite/study-service

permissions:
  contents: read
  checks: write
  pull-requests: write
  packages: write

jobs:
  test:
    name: Build and Test
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'
        cache: 'gradle'
    
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
    
    - name: Cache Gradle packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
    
    - name: Configure Gradle properties
      run: |
        mkdir -p ~/.gradle
        echo "gpr.user=${{ github.actor }}" >> ~/.gradle/gradle.properties
        echo "gpr.key=${{ secrets.GITHUB_TOKEN }}" >> ~/.gradle/gradle.properties
        
    - name: Build with Gradle (skip tests)
      run: ./gradlew build -x test --no-daemon --stacktrace
      env:
        USERNAME: ${{ github.actor }}
        TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Run tests
      run: ./gradlew test --no-daemon --stacktrace
      env:
        USERNAME: ${{ github.actor }}
        TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: '**/build/test-results/test/'
        retention-days: 7
    
    - name: Upload test reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-reports
        path: '**/build/reports/tests/'
        retention-days: 7

  deploy-infrastructure:
    name: Deploy Infrastructure (MySQL & Redis)
    needs: test
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'push' && 
      (contains(github.ref, 'main') || contains(github.ref, 'feature/'))
    
    steps:
    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" | base64 -d > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        ssh-keyscan -p 2222 -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts
    
    - name: Deploy infrastructure services
      run: |
        ssh -p 2222 -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'ENDSSH'
          echo "Checking and deploying infrastructure services..."
          
          # Navigate to deployment directory
          cd ~/deployments/infrastructure || mkdir -p ~/deployments/infrastructure && cd ~/deployments/infrastructure
          
          # Check if MySQL is already running
          MYSQL_RUNNING=$(docker ps --filter "name=asyncsite-mysql" --filter "status=running" -q)
          if [ -n "$MYSQL_RUNNING" ]; then
            echo "MySQL container is already running, skipping MySQL deployment"
          else
            echo "MySQL container not running, will deploy MySQL"
            DEPLOY_MYSQL=true
          fi
          
          # Check if Redis is already running
          REDIS_RUNNING=$(docker ps --filter "name=asyncsite-redis" --filter "status=running" -q)
          if [ -n "$REDIS_RUNNING" ]; then
            echo "Redis container is already running, skipping Redis deployment"
          else
            echo "Redis container not running, will deploy Redis"
            DEPLOY_REDIS=true
          fi
          
          # Only proceed if we need to deploy something
          if [ "$DEPLOY_MYSQL" = "true" ] || [ "$DEPLOY_REDIS" = "true" ]; then
            # Create docker-compose file for infrastructure
            cat > docker-compose.yml << COMPOSE_EOF
          services:
            mysql:
              image: mysql:8.0
              container_name: asyncsite-mysql
              ports:
                - "3306:3306"
              environment:
                - MYSQL_ROOT_PASSWORD=asyncsite_root_2024!
                - MYSQL_CHARACTER_SET_SERVER=utf8mb4
                - MYSQL_COLLATION_SERVER=utf8mb4_unicode_ci
              volumes:
                - asyncsite-mysql-data:/var/lib/mysql
                - ./mysql/init:/docker-entrypoint-initdb.d
              networks:
                - asyncsite-network
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
                interval: 10s
                timeout: 5s
                retries: 5
                
            redis:
              image: redis:7-alpine
              container_name: asyncsite-redis
              ports:
                - "6379:6379"
              volumes:
                - asyncsite-redis-data:/data
              networks:
                - asyncsite-network
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "redis-cli", "ping"]
                interval: 10s
                timeout: 5s
                retries: 3
          
          networks:
            asyncsite-network:
              external: true
          
          volumes:
            asyncsite-redis-data:
              driver: local
            asyncsite-mysql-data:
              driver: local
        COMPOSE_EOF
            
            # Copy MySQL init scripts
            mkdir -p ./mysql/init
            cat > ./mysql/init/01-create-databases.sql << 'SQLEOF'
        -- Create databases for different microservices
        CREATE DATABASE IF NOT EXISTS studydb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
        CREATE DATABASE IF NOT EXISTS userdb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
        CREATE DATABASE IF NOT EXISTS asyncsite CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
        
        -- Grant privileges
        GRANT ALL PRIVILEGES ON studydb.* TO 'root'@'%';
        GRANT ALL PRIVILEGES ON userdb.* TO 'root'@'%';
        GRANT ALL PRIVILEGES ON asyncsite.* TO 'root'@'%';
        FLUSH PRIVILEGES;
        SQLEOF
            
            # Start infrastructure containers
            docker compose up -d
            
            echo "Infrastructure deployment completed!"
          else
            echo "All infrastructure services are already running, skipping deployment"
          fi
        ENDSSH

  build-and-push:
    name: Build and Push Docker Image
    needs: test
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'push' && 
      (contains(github.ref, 'main') || contains(github.ref, 'feature/'))
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'
        cache: 'gradle'
    
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
    
    - name: Configure Gradle properties
      run: |
        mkdir -p ~/.gradle
        echo "gpr.user=${{ github.actor }}" >> ~/.gradle/gradle.properties
        echo "gpr.key=${{ secrets.GITHUB_TOKEN }}" >> ~/.gradle/gradle.properties
    
    - name: Build application
      run: ./gradlew build -x test --no-daemon
      env:
        USERNAME: ${{ github.actor }}
        TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: |
          ${{ env.IMAGE_NAME }}:latest
          ${{ env.IMAGE_NAME }}:${{ github.sha }}

  deploy:
    name: Deploy Study Service
    needs: [build-and-push, deploy-infrastructure]
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'push' && 
      (contains(github.ref, 'main') || contains(github.ref, 'feature/'))
    
    steps:
    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" | base64 -d > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        ssh-keyscan -p 2222 -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts
    
    - name: Deploy study-service
      run: |
        ssh -p 2222 -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'ENDSSH'
          echo "Starting deployment of study-service..."
          
          # Navigate to deployment directory
          cd ~/deployments/study-service || mkdir -p ~/deployments/study-service && cd ~/deployments/study-service
          
          # Create docker-compose file
          cat > docker-compose.yml << COMPOSE_EOF
          services:
            study-service:
              image: ${{ env.IMAGE_NAME }}:${{ github.sha }}
              container_name: asyncsite-study-service
              ports:
                - "8083:8083"
              environment:
                - SPRING_PROFILES_ACTIVE=docker
                - EUREKA_CLIENT_ENABLED=true
                - EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE=http://asyncsite-eureka:8761/eureka/
                - EUREKA_INSTANCE_PREFER_IP_ADDRESS=true
                - EUREKA_INSTANCE_INSTANCE_ID=\${HOSTNAME}:study-service:8083
                - EUREKA_INSTANCE_METADATA_MAP_VERSION=1.0.0
                - EUREKA_INSTANCE_METADATA_MAP_ZONE=docker
                - SPRING_DATASOURCE_URL=jdbc:mysql://asyncsite-mysql:3306/studydb?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true&characterEncoding=utf8&useUnicode=true
                - SPRING_DATASOURCE_USERNAME=root
                - SPRING_DATASOURCE_PASSWORD=asyncsite_root_2024!
                - SPRING_DATASOURCE_DRIVER_CLASS_NAME=com.mysql.cj.jdbc.Driver
                - SPRING_JPA_HIBERNATE_DDL_AUTO=update
                - SPRING_JPA_SHOW_SQL=false
                - SPRING_JPA_PROPERTIES_HIBERNATE_DIALECT=org.hibernate.dialect.MySQLDialect
                - SPRING_JPA_PROPERTIES_HIBERNATE_FORMAT_SQL=false
                - LOGGING_LEVEL_COM_ASYNCSITE_STUDYSERVICE=INFO
                - LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_SECURITY=INFO
                - LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=INFO
                - MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE=health,info,metrics
                - MANAGEMENT_ENDPOINT_HEALTH_SHOW_DETAILS=always
                - MANAGEMENT_HEALTH_DB_ENABLED=true
              networks:
                - asyncsite-network
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8083/actuator/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 60s
          
          networks:
            asyncsite-network:
              external: true
        COMPOSE_EOF
          
          # Login to GitHub Container Registry
          echo "${{ secrets.PAT_TOKEN }}" | docker login ghcr.io -u renechoi --password-stdin
          
          # Pull latest image
          docker pull ${{ env.IMAGE_NAME }}:${{ github.sha }}
          
          # Stop and remove old container
          docker stop asyncsite-study-service 2>/dev/null || true
          docker rm asyncsite-study-service 2>/dev/null || true
          
          # Start new containers
          docker compose up -d
          
          # Wait for services to be healthy
          echo "Waiting for services to be healthy..."
          sleep 45
          
          # Check service status
          docker ps | grep asyncsite-study-service
          
          echo "Study service deployment completed!"
        ENDSSH